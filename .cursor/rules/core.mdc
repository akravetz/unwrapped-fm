---
description:
globs:
alwaysApply: true
---
# Core Project Rules - unwrapped.fm

## Critical Implementation Rules ⚠️

### NEVER Edit Dependencies Directly
- **ALWAYS use `uv add package-name`** for adding dependencies
- **NEVER edit pyproject.toml directly** for dependencies
- Example: `uv add "python-jose[cryptography]"` (note the quotes for extras)

### Modern Python Typing (Phase 2 Established)
- **Use `|` union syntax**: `str | None` instead of `Optional[str]`
- **Modern imports**: `from collections.abc import AsyncGenerator` not `typing.AsyncGenerator`
- **No deprecated imports**: Never import from `typing.Optional`, `typing.Dict`, etc.
- **Modern datetime**: `from datetime import UTC` instead of `timezone.utc`
- **Timezone-aware fields**: Use `datetime.now(UTC)` and `DateTime(timezone=True)` for database columns
- **No deprecated datetime**: Never use `datetime.utcnow()` - always `datetime.now(UTC)`

### Pydantic v2 Compliance
- **Use `ConfigDict`**: `model_config = ConfigDict(env_file=".env")`
- **NEVER use class-based Config**: Deprecated and causes warnings
- **Modern field definitions**: Use Field() for complex validations

### Exception Handling
- **Always chain exceptions**: `raise HTTPException(...) from e`
- **Never bare except**: Always specify exception types or use `from e`

### Async Patterns
- **Async everywhere**: Database operations, HTTP calls, file I/O
- **Proper session management**: Use `Depends(get_session)` for database
- **Context managers**: `async with httpx.AsyncClient() as client:`

### SSR-Compatible Architecture (MANDATORY) ⚠️
- **NEVER use `typeof window !== 'undefined'` checks**: Anti-pattern for SSR
- **ALWAYS separate HTTP clients from browser APIs**: Clean architecture
- **ALWAYS use SSR-safe hooks**: Return null during SSR, handle gracefully
- **ALWAYS pass tokens explicitly**: No hidden dependencies in interceptors

#### Required Pattern for API Access
```typescript
// ✅ CORRECT: SSR-safe hook pattern
export function useApiClient(): AuthenticatedApiClient | null {
  const [isClient, setIsClient] = useState(false);
  useEffect(() => setIsClient(true), []);
  if (!isClient) return null; // SSR-safe
  // ... return client with explicit token management
}

// ✅ CORRECT: Component usage
function MyComponent() {
  const apiClient = useApiClient();
  useEffect(() => {
    if (!apiClient) return; // Always check for null
    apiClient.getCurrentUser().then(setUser);
  }, [apiClient]);
}
```

## Background Task Architecture ✅ IMPLEMENTED NEW!

### Background Task Patterns (Production Ready)
- **Status-driven processing**: Use enum status fields (PENDING/PROCESSING/COMPLETED/FAILED)
- **Idempotent operations**: Begin endpoint returns existing or creates new
- **One analysis per user**: Database unique constraint on user_id
- **Comprehensive error handling**: Log errors and update database status
- **Atlas migrations**: Use `task db:migrate:diff` and `task db:migrate:apply`

#### Required Background Task Service Pattern
```python
# ✅ CORRECT: Three-method background task pattern
class MusicAnalysisService:
    async def begin_analysis(self, user_id: int) -> MusicAnalysisResult:
        """Idempotent: Returns existing or creates new analysis"""

    async def poll_analysis(self, user_id: int) -> AnalysisStatusResponse:
        """Real-time status with timestamps"""

    async def get_analysis(self, user_id: int) -> MusicAnalysisResult:
        """Validates completed status and returns results"""

# ✅ CORRECT: Background processing with error handling
async def process_music_analysis_task(analysis_id: int):
    try:
        # Update status to PROCESSING
        # Run actual analysis
        # Update status to COMPLETED
    except Exception as e:
        # Log error and update status to FAILED
        logger.error(f"Analysis failed: {e}")
        # Update error_message in database
```

#### Required Database Schema Pattern
```python
# ✅ CORRECT: Status tracking with unique constraint
class MusicAnalysisResult(SQLModel, table=True):
    status: AnalysisStatus = Field(default=AnalysisStatus.PENDING)
    error_message: str | None = Field(default=None)
    started_at: datetime | None = Field(default=None)
    completed_at: datetime | None = Field(default=None)
    user_id: int = Field(foreign_key="user.id", unique=True)  # One per user

    # Analysis fields nullable for pending state
    ai_analysis: str | None = Field(default=None)
    music_data: dict | None = Field(default=None)
```

#### Required API Endpoint Pattern
```python
# ✅ CORRECT: RESTful background task endpoints
@router.post("/analysis/begin")  # Idempotent
@router.get("/analysis/status")  # Status polling
@router.get("/analysis/result")  # Result retrieval

# ✅ CORRECT: FastAPI BackgroundTasks integration
async def begin_background_analysis(
    background_tasks: BackgroundTasks,
    current_user: User = Depends(get_current_user),
    service: MusicAnalysisService = Depends(get_music_analysis_service)
):
    analysis = await service.begin_analysis(current_user.id)
    if analysis.status == AnalysisStatus.PENDING:
        background_tasks.add_task(process_music_analysis_task, analysis.id)
    return analysis
```

### Atlas Migration Workflow (MANDATORY)
- **NEVER edit database schema manually**: Always use Atlas migrations
- **Generate migrations**: `task db:migrate:diff <descriptive_name>`
- **Apply migrations**: `task db:migrate:apply`
- **Version control**: All migrations committed to git
- **Team collaboration**: Migrations ensure consistent schema across environments

## Authentication Architecture ✅ IMPLEMENTED

### JWT + Spotify OAuth Flow
```python
# 1. Generate auth URL
auth_url = spotify_client.get_auth_url()

# 2. Handle callback
spotify_token = await spotify_client.exchange_code_for_token(code)
spotify_user = await spotify_client.get_current_user(spotify_token.access_token)

# 3. Create/update user
user = await user_service.create_or_update_user_from_spotify(...)

# 4. Generate JWT
jwt_token = create_user_token(user.id)
```

### Database Patterns
- **Service Layer**: Separate UserService for database operations
- **Modern SQLModel**: Async with proper typing
- **Token Storage**: Store Spotify tokens with expiration handling

## Code Quality Standards

### Testing
- **Current coverage**: 45% - good baseline
- **Test structure**: Keep tests focused and fast
- **Async tests**: Use proper pytest-asyncio patterns

### Linting & Formatting
- **Always run**: `uv run ruff check . && uv run ruff format .`
- **Fix automatically**: `uv run ruff check . --fix`
- **Zero tolerance**: No linting errors in committed code

## Development Workflow

### Backend Commands
```bash
cd backend/
uv run uvicorn src.unwrapped.main:app --reload  # Dev server
uv run pytest                                     # Tests
uv run ruff check . && uv run ruff format .      # Quality check
```

### Frontend Commands
```bash
cd frontend/
npm run dev    # Dev server
npm run build  # Production build
```

### IMPORTANT
ALWAYS CONFIRM THE DIRECTORY YOU THINK YOU ARE WORKING IN BEFORE CREATING FILES.  ALL FRONTEND CODE SHOULD BE IN THE `frontend/` DIRECTORY. ALL BACKEND CODE SHOULD BE IN THE `backend/` directory


## Next Phase Preparation (Phase 3: Music Data)

### Spotify API Integration
- **Rate limiting**: Implement proper backoff strategies
- **Data pagination**: Handle large music libraries efficiently
- **Token refresh**: Automatic refresh of expired Spotify tokens
- **Error handling**: Graceful degradation for API failures

### Data Processing
- **Async processing**: Use background tasks for heavy operations
- **Caching strategy**: Cache frequently accessed music data
- **Database design**: Efficient models for music data storage

You have two modes of operation:

1. Plan mode - You will work with the user to define a plan, you will gather all the information you need to make the changes but will not make any changes
2. Act mode - You will make changes to the codebase based on the plan

- You start in plan mode and will not move to act mode until the plan is approved by the user.
- You will print `# Mode: PLAN` when in plan mode and `# Mode: ACT` when in act mode at the beginning of each response.
- Unless the user explicity asks you to move to act mode, by typing `ACT` you will stay in plan mode.
- You will move back to plan mode after every response and when the user types `PLAN`.
- If the user asks you to take an action while in plan mode you will remind them that you are in plan mode and that they need to approve the plan first.
- When in plan mode always output the full updated plan in every response.
